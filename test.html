<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Intercom â€“ Room Selector</title>
  <style>
    /* â”€â”€ Catppuccin Mocha palette â”€â”€ */
    :root {
      --ctp-crust:    #11111b;
      --ctp-mantle:   #181825;
      --ctp-surface0: #313244;
      --ctp-surface1: #45475a;
      --ctp-surface2: #585b70;
      --ctp-overlay0: #6c7086;
      --ctp-overlay1: #7f849c;
      --ctp-text:     #cdd6f4;
      --ctp-lavender: #b4befe;
      --ctp-blue:     #89b4fa;
      --ctp-red:      #f38ba8;
      --ctp-green:    #a6e3a1;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--ctp-crust);
      color: var(--ctp-text);
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    /* â”€â”€ Layout: 60 / 40 split â”€â”€ */
    .intercom-container {
      width: min(480px, 92vw);
      height: 150px;
      display: flex;
      gap: 25px;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 8px 40px #00000060;
      background: var(--ctp-mantle);
      padding: 12px;
    }

    .picker-panel {
      width: 60%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: center;
      position: relative;
      user-select: none;
      -webkit-user-select: none;
      overflow: hidden;
    }

    .picker-label {
      font-size: 18px;
      line-height: 24px;
      font-weight: 500;
      letter-spacing: -0.01em;
      color: var(--ctp-text);
      padding: 2px 4px 6px;
      width: 100%;
    }

    /* â”€â”€ iOS-style drum picker â”€â”€ */
    .picker-wheel {
      position: relative;
      width: 100%;
      height: 100%;            /* fill available space */
      overflow: hidden;
      cursor: grab;
      -webkit-mask-image: linear-gradient(
        to bottom,
        transparent 0%,
        rgba(0,0,0,0.4) 5%,
        black 15%,
        black 85%,
        rgba(0,0,0,0.4) 95%,
        transparent 100%
      );
      mask-image: linear-gradient(
        to bottom,
        transparent 0%,
        rgba(0,0,0,0.4) 5%,
        black 15%,
        black 85%,
        rgba(0,0,0,0.4) 95%,
        transparent 100%
      );
    }

    .picker-wheel.grabbing { cursor: grabbing; }

    /* Selection highlight band */
    .picker-highlight {
      position: absolute;
      top: 50%;
      left: 4px;
      right: 4px;
      height: 40px;
      transform: translateY(-50%);
      border: 1.5px solid var(--ctp-surface2);
      border-left: none;
      border-right: none;
      border-radius: 8px;
      background: var(--ctp-surface0);
      pointer-events: none;
      z-index: 1;
    }

    /* Track that moves up/down */
    .picker-track {
      position: absolute;
      left: 0; right: 0;
      will-change: transform;
      z-index: 2;
    }

    .picker-item {
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding-left: 10px;
      gap: 8px;
      font-size: 14px;
      font-weight: 400;
      color: var(--ctp-overlay0);
      white-space: nowrap;
      transition: color 0.15s, font-weight 0.15s;
      pointer-events: none;
    }

    .picker-item.selected {
      color: var(--ctp-text);
      font-weight: 500;
    }

    .picker-item .icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      color: var(--ctp-blue);
      opacity: 0.6;
    }
    .picker-item .icon svg {
      width: 100%;
      height: 100%;
      display: block;
      fill: none;
      stroke: currentColor;
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .picker-item.selected .icon {
      color: var(--ctp-lavender);
      opacity: 1;
    }

    /* â”€â”€ Right panel â€“ swipe to dial â”€â”€ */
    .right-panel {
      width: 40%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 0 0 8px;
      user-select: none;
      -webkit-user-select: none;
    }

    .swipe-label {
      font-size: 0.6rem;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--ctp-overlay1);
    }

    /* â”€â”€ Swipe track (horizontal, left-to-right) â”€â”€ */
    .swipe-track {
      position: relative;
      width: 100%;
      height: 60px;
      border-radius: 30px;
      background: var(--ctp-surface0);
      overflow: hidden;
      touch-action: none;
    }

    /* Destination bell (right end, grey) */
    .swipe-dest {
      position: absolute;
      right: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: var(--ctp-surface1);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      opacity: 0.4;
      transition: opacity 0.2s, background 0.3s;
    }
    .swipe-dest.active {
      opacity: 1;
      background: var(--ctp-green);
    }
    .swipe-dest svg { width: 22px; height: 22px; }

    /* Chevrons (static horizontal, react to drag) */
    .swipe-chevrons {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 4px;
      pointer-events: none;
    }
    .swipe-chevrons .chev {
      font-size: 1rem;
      line-height: 1;
      color: var(--ctp-overlay0);
      transition: color 0.15s, opacity 0.15s;
    }
    .swipe-chevrons .chev:nth-child(1) { opacity: 0.8; }
    .swipe-chevrons .chev:nth-child(2) { opacity: 0.5; }
    .swipe-chevrons .chev:nth-child(3) { opacity: 0.25; }

    @keyframes chev-pulse {
      0%, 100% { opacity: 0.15; }
      50%      { opacity: 0.7; }
    }
    .swipe-chevrons.idle .chev:nth-child(1) { animation: chev-pulse 1.6s ease-in-out 0s infinite; }
    .swipe-chevrons.idle .chev:nth-child(2) { animation: chev-pulse 1.6s ease-in-out 0.25s infinite; }
    .swipe-chevrons.idle .chev:nth-child(3) { animation: chev-pulse 1.6s ease-in-out 0.5s infinite; }

    /* Lit-up chevron when drag passes it */
    .swipe-chevrons .chev.lit {
      color: var(--ctp-lavender);
      opacity: 1 !important;
    }

    /* Draggable knob (red bell) */
    .swipe-knob {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 52px;
      height: 52px;
      border-radius: 50%;
      background: var(--ctp-red);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      z-index: 3;
      box-shadow: 0 4px 16px #f38ba840;
      transition: box-shadow 0.2s;
      will-change: left;
    }
    .swipe-knob.grabbing { cursor: grabbing; box-shadow: 0 6px 24px #f38ba860; }
    .swipe-knob svg { width: 24px; height: 24px; }

    .swipe-knob.success {
      background: var(--ctp-green);
      box-shadow: 0 4px 16px #a6e3a140;
    }
  </style>
</head>
<body>

<div class="intercom-container">
  <!-- 60 % â€“ Room picker -->
  <div class="picker-panel">
    <div class="picker-label">Select Room</div>
    <div class="picker-wheel" id="pickerWheel">
      <div class="picker-highlight"></div>
      <div class="picker-track" id="pickerTrack"></div>
    </div>
  </div>

  <!-- 40 % â€“ Swipe to dial -->
  <div class="right-panel">
    <div class="swipe-label">Swipe to Dial</div>
    <div class="swipe-track" id="swipeTrack">
      <!-- Draggable knob -->
      <div class="swipe-knob" id="swipeKnob">
        <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
          <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
          <line x1="12" y1="2" x2="12" y2="4"/>
        </svg>
      </div>

      <!-- Animated chevrons -->
      <div class="swipe-chevrons idle" id="swipeChevrons">
        <span class="chev">&#x203A;</span>
        <span class="chev">&#x203A;</span>
        <span class="chev">&#x203A;</span>
      </div>

      <!-- Destination -->
      <div class="swipe-dest" id="swipeDest">
        <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
          <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
        </svg>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  /* â”€â”€ Data â”€â”€ */
  const rooms = [
    { name: 'Living Room',     icon: '<svg viewBox="0 0 24 24"><path d="M5 12V7a7 7 0 0 1 14 0v5"/><path d="M3 12h18v4a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4v-4z"/></svg>' },
    { name: 'Family Area',     icon: '<svg viewBox="0 0 24 24"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9z"/><path d="M9 22V12h6v10"/></svg>' },
    { name: 'Master Bedroom',  icon: '<svg viewBox="0 0 24 24"><path d="M2 16V8a4 4 0 0 1 4-4h12a4 4 0 0 1 4 4v8"/><path d="M2 16h20v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-2z"/><path d="M6 12h12v4H6z"/></svg>' },
    { name: 'Gary\'s Phone',    icon: '<svg viewBox="0 0 24 24"><path d="M8 2h8a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"/><circle cx="12" cy="18" r="1"/></svg>' },
    { name: 'Serena\'s Phone',  icon: '<svg viewBox="0 0 24 24"><path d="M8 2h8a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"/><circle cx="12" cy="18" r="1"/></svg>' },
  ];

  /* â”€â”€ Build DOM â”€â”€ */
  const track = document.getElementById('pickerTrack');
  const wheel = document.getElementById('pickerWheel');

  const ITEM_H    = 40;                       // px per row
  const WHEEL_H   = wheel.clientHeight || 106; // measured from actual el
  // Pixel offset so item 0 sits centred in the wheel
  const CENTER_OFFSET = Math.round((WHEEL_H - ITEM_H) / 2);

  // No padding items â€” we use a CSS top offset on the track instead

  // Add real items only
  rooms.forEach((r, i) => {
    const d = document.createElement('div');
    d.className = 'picker-item';
    d.dataset.index = i;
    d.innerHTML = `<span class="icon">${r.icon}</span>${r.name}`;
    track.appendChild(d);
  });

  // Position track so item 0 is centered
  track.style.top = CENTER_OFFSET + 'px';

  /* â”€â”€ State â”€â”€ */
  let selectedIndex = 0;
  let offset        = 0;   // current translateY (negative = scrolled down)
  let velocity       = 0;
  let dragging       = false;
  let startY, startOffset, lastY, lastTime;
  let animFrame      = null;
  let wheelSnapTimer  = 0;

  const minOffset = -(rooms.length - 1) * ITEM_H;
  const maxOffset = 0;

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  function applyOffset(o) {
    offset = o;
    track.style.transform = `translateY(${o}px)`;
    // Determine closest index
    const idx = clamp(Math.round(-o / ITEM_H), 0, rooms.length - 1);
    if (idx !== selectedIndex) {
      selectedIndex = idx;
      updateSelection();
    }
  }

  function updateSelection() {
    track.querySelectorAll('.picker-item[data-index]').forEach(el => {
      el.classList.toggle('selected', +el.dataset.index === selectedIndex);
    });
  }

  function snapTo(idx) {
    const target = -idx * ITEM_H;
    cancelAnimationFrame(animFrame);
    const start  = offset;
    const dist   = target - start;
    const dur    = 320; // ms
    const t0     = performance.now();
    function tick(now) {
      const p = Math.min((now - t0) / dur, 1);
      // ease-out cubic
      const ease = 1 - Math.pow(1 - p, 3);
      applyOffset(start + dist * ease);
      if (p < 1) animFrame = requestAnimationFrame(tick);
    }
    animFrame = requestAnimationFrame(tick);
  }

  /* â”€â”€ Momentum coast + snap â”€â”€ */
  function coast() {
    cancelAnimationFrame(animFrame);
    const friction = 0.94;
    function tick() {
      velocity *= friction;
      let next = offset + velocity;
      // Rubber-band at bounds
      if (next > maxOffset) { next = maxOffset + (next - maxOffset) * 0.3; velocity *= 0.5; }
      if (next < minOffset) { next = minOffset + (next - minOffset) * 0.3; velocity *= 0.5; }
      applyOffset(next);
      if (Math.abs(velocity) > 0.3) {
        animFrame = requestAnimationFrame(tick);
      } else {
        // Snap to nearest
        snapTo(clamp(Math.round(-offset / ITEM_H), 0, rooms.length - 1));
      }
    }
    animFrame = requestAnimationFrame(tick);
  }

  /* â”€â”€ Pointer events â”€â”€ */
  wheel.addEventListener('pointerdown', e => {
    cancelAnimationFrame(animFrame);
    dragging    = true;
    startY      = e.clientY;
    startOffset = offset;
    lastY       = e.clientY;
    lastTime    = performance.now();
    velocity    = 0;
    wheel.classList.add('grabbing');
    wheel.setPointerCapture(e.pointerId);
    e.preventDefault();
  });

  wheel.addEventListener('pointermove', e => {
    if (!dragging) return;
    const dy  = e.clientY - startY;
    let next  = startOffset + dy;

    // Rubber-band beyond edges
    if (next > maxOffset) next = maxOffset + (next - maxOffset) * 0.35;
    if (next < minOffset) next = minOffset + (next - minOffset) * 0.35;

    applyOffset(next);

    // Track velocity
    const now = performance.now();
    const dt  = now - lastTime;
    if (dt > 0) {
      velocity = (e.clientY - lastY) / dt * 16; // px per frame (~16ms)
      lastY    = e.clientY;
      lastTime = now;
    }
  });

  function endDrag() {
    if (!dragging) return;
    dragging = false;
    wheel.classList.remove('grabbing');
    if (Math.abs(velocity) > 1.5) {
      coast();
    } else {
      snapTo(clamp(Math.round(-offset / ITEM_H), 0, rooms.length - 1));
    }
  }

  wheel.addEventListener('pointerup',     endDrag);
  wheel.addEventListener('pointercancel', endDrag);

  /* â”€â”€ Mouse-wheel / trackpad â”€â”€ */
  wheel.addEventListener('wheel', e => {
    e.preventDefault();
    cancelAnimationFrame(animFrame);
    let next = offset - e.deltaY;
    next = clamp(next, minOffset, maxOffset);
    applyOffset(next);
    clearTimeout(wheelSnapTimer);
    wheelSnapTimer = setTimeout(() => {
      snapTo(clamp(Math.round(-offset / ITEM_H), 0, rooms.length - 1));
    }, 120);
  }, { passive: false });

  /* â”€â”€ Init â”€â”€ */
  applyOffset(0);
  updateSelection();
})();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   Swipe-to-dial  (horizontal, left â†’ right)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
(() => {
  const track    = document.getElementById('swipeTrack');
  const knob     = document.getElementById('swipeKnob');
  const chevrons = document.getElementById('swipeChevrons');
  const chevEls  = chevrons.querySelectorAll('.chev');
  const dest     = document.getElementById('swipeDest');

  const KNOB_SIZE = 52;
  const PAD       = 4;   // left/right padding inside track
  const REST_LEFT = PAD;

  let dragging = false, startX, startLeft, trackW, maxLeft;

  function measure() {
    trackW  = track.clientWidth;
    maxLeft = trackW - KNOB_SIZE - PAD;
  }

  /* Place chevrons in fixed centre between rest-knob-end and dest-start */
  function layoutChevrons() {
    const knobEnd   = REST_LEFT + KNOB_SIZE;
    const destStart = trackW - KNOB_SIZE - PAD;
    const centre    = (knobEnd + destStart) / 2;
    const chevsW    = chevrons.offsetWidth || 48;
    chevrons.style.left = (centre - chevsW / 2) + 'px';
  }

  /* Light up chevrons based on drag progress (0â†’1) */
  function updateChevrons(progress) {
    const thresholds = [0.2, 0.45, 0.7];
    chevEls.forEach((el, i) => {
      el.classList.toggle('lit', progress >= thresholds[i]);
    });
  }

  /* â”€â”€ Pointer events â”€â”€ */
  knob.addEventListener('pointerdown', e => {
    measure();
    dragging  = true;
    startX    = e.clientX;
    startLeft = knob.offsetLeft;
    knob.classList.add('grabbing');
    knob.setPointerCapture(e.pointerId);
    chevrons.classList.remove('idle');
    e.preventDefault();
  });

  knob.addEventListener('pointermove', e => {
    if (!dragging) return;
    let newLeft = startLeft + (e.clientX - startX);
    newLeft = Math.max(REST_LEFT, Math.min(newLeft, maxLeft));
    knob.style.left = newLeft + 'px';

    const progress = (newLeft - REST_LEFT) / (maxLeft - REST_LEFT);
    dest.style.opacity = 0.4 + progress * 0.6;
    updateChevrons(progress);
  });

  function endSwipe() {
    if (!dragging) return;
    dragging = false;
    knob.classList.remove('grabbing');

    const currentLeft = knob.offsetLeft;
    const progress    = (currentLeft - REST_LEFT) / (maxLeft - REST_LEFT);

    if (progress > 0.8) {
      triggerDial();
    } else {
      resetKnob();
    }
  }

  knob.addEventListener('pointerup',     endSwipe);
  knob.addEventListener('pointercancel', endSwipe);

  function resetKnob() {
    knob.style.transition = 'left 0.35s cubic-bezier(.2,.8,.3,1)';
    knob.style.left = REST_LEFT + 'px';
    dest.style.opacity = 0.4;
    chevrons.classList.add('idle');
    updateChevrons(0);
    setTimeout(() => { knob.style.transition = ''; }, 360);
  }

  function triggerDial() {
    knob.style.transition = 'left 0.2s ease-out';
    knob.style.left = maxLeft + 'px';
    dest.classList.add('active');
    knob.classList.add('success');
    updateChevrons(1);

    // TODO: actually call intercom service here
    console.log('ðŸ”” Dialling intercomâ€¦');

    setTimeout(() => {
      dest.classList.remove('active');
      knob.classList.remove('success');
      resetKnob();
    }, 1600);
  }

  /* â”€â”€ Init â”€â”€ */
  measure();
  layoutChevrons();
  window.addEventListener('resize', () => { measure(); layoutChevrons(); });
})();
</script>
</body>
</html>
